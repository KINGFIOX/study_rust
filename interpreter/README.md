# README

## RefCell 与 RC（reference count）

在 Rust 中，`Rc`和`RefCell`是两个用于管理内存的工具，它们各自解决不同的问题，但经常一起使用以提供更多的灵活性。

### Rc

`Rc<T>`是一个引用计数指针，"Rc"代表"Reference Counted"。
它允许多个所有者拥有同一个数据，数据的内存会在没有任何所有者时自动释放。`Rc`只能用于单线程场景。

使用`Rc`可以让多个变量共享数据的所有权，而不必明确地跟踪所有者数量来确保数据在不再被需要时被释放。
每当你克隆一个`Rc<T>`实例时，数据的引用计数会增加，当`Rc`实例被丢弃时，计数会减少。当引用计数归零时，数据会被自动清理。

### RefCell

`RefCell<T>`提供了内部可变性。即使在`RefCell<T>`自身被标记为不可变时，它也允许借用或修改其内部的`T`数据。
这是通过`borrow`和`borrow_mut`方法实现的，分别用于获取`T`数据的不可变和可变引用。

`RefCell`在运行时检查借用规则，确保在任何给定时间，要么只有一个可变引用，要么有多个不可变引用，但两者不能共存。
如果违反了这些规则，`RefCell`会导致程序在运行时崩溃，而不是在编译时捕捉到错误。

### Rc + RefCell 组合

单独使用时，`Rc`不允许内部数据的可变性（因为你无法确保安全修改数据，而不违反 Rust 的借用规则），而`RefCell`不提供多所有者能力。
将它们组合使用，即`Rc<RefCell<T>>`，可以同时获得多所有者和内部可变性的能力。
这种组合非常有用，特别是在需要多个地方共享和修改同一数据，但又想遵守 Rust 的所有权和借用规则时。

这种方式在图形用户界面（GUI）库、图数据结构和一些需要共享可变状态的场景中非常常见。

### 示例

以下是一个简单的示例，展示了如何使用`Rc<RefCell<T>>`来共享和修改数据：

```rust
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let value_a = Rc::clone(&value);
    let value_b = Rc::clone(&value);

    *value.borrow_mut() += 10;
    println!("value_a: {}", value_a.borrow());
    println!("value_b: {}", value_b.borrow());
}
```

在这个示例中，`value`是通过`Rc<RefCell<i32>>`共享的，
这意味着我们可以在`value_a`和`value_b`之间共享对`i32`值的所有权，并且能够修改这个值，即使它是通过不可变引用访问的。

## 上值

关闭上值（closing an upvalue）是在某些编程语言中管理闭包生命周期的一个重要步骤，
特别是在使用栈来管理作用域和函数调用的语言中，如 Lua 和某些实现 JavaScript 的虚拟机。
这个过程涉及到将闭包中引用的外部变量（即上值）的状态从"开放"（即直接引用栈上的变量）转变为"闭合"
（即将变量的值复制到堆上，以便在栈帧被弹出后仍然可以访问该值）。

### 为什么要关闭上值？

1. **保持变量的生命周期**：函数执行完毕后，其栈帧（包括局部变量）会被销毁。
   如果一个闭包尝试访问这些已经被销毁的局部变量，就会导致未定义行为。
   通过关闭上值，我们将这些变量的值保存在一个更持久的存储位置（如堆），从而即使函数栈帧被销毁，闭包仍然可以安全地访问这些值。

2. **实现闭包的语义**：闭包的一个核心特性是能够捕获并持续访问其定义时作用域中的变量。
   关闭上值是实现这一特性的机制之一，它确保闭包能够在其定义环境之外正常运行，并访问那些变量。

### 关闭上值的过程

- **开放的上值**：当闭包创建时，它会捕获一些局部变量的引用。
  如果这些变量位于栈上，这些引用就指向栈中的具体位置。
  这些变量称为"开放的上值"，因为它们直接关联到栈上的活动记录。

- **闭合的上值**：当包含这些局部变量的函数返回时，栈帧会被销毁，原本指向栈上的引用变得无效。
  此时，如果有闭包引用了这些变量，虚拟机会将这些变量的值"复制"到堆上，并更新闭包的引用，指向这些新的、在堆上的变量副本。
  这个过程称为"关闭上值"。这样，即使原始栈帧被销毁，闭包也可以通过这些复制到堆上的值继续工作。

### 举例说明

假设有一个函数`A`，它定义了一个局部变量`x`和一个内部函数`B`（闭包），`B`访问了`x`。当`A`执行并返回后，按理来说`x`的生命周期就结束了。
但是，由于`B`可能在`A`执行完毕后被调用，并且需要访问`x`，因此在`A`返回时，`x`会被关闭（即其值被复制到堆上），
这样`B`就可以安全地访问`x`的副本，而不用担心`x`会因为栈帧的销毁而消失。

关闭上值是实现高级语言特性（如闭包）的虚拟机和解释器中的一种重要技术，它关乎于程序的正确性和变量作用域的管理。
