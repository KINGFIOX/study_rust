### å·²ç»æœ‰äº†ä¸å¯å˜çš„å€Ÿç”¨ å°±æ— æ³•å†æ‹¥æœ‰å¯å˜å€Ÿç”¨

é”™è¯¯ç¤ºä¾‹

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
fn first_word(s: &String) -> &str {
    &s[..1]
}
```

è¿™æ®µæŠ¥é”™ï¼š

```rust
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```

### æŒ‡é’ˆ

1. ä¼ å…¥ Box çš„ ä¸å¯å˜ å¼•ç”¨

å¦‚æœè¦ä½¿ç”¨ str ç±»å‹ï¼Œåªèƒ½é…åˆ Boxã€‚ & å¯ä»¥ç”¨æ¥å°† `Box<str>` è½¬æ¢ä¸º &str ç±»å‹

```rust
fn main() {
    let s: Box<str> = "hello, world".into();
    greetings(&s)
}

fn greetings(s: &str) {
    println!("{}",s)
}
```

2. è§£å¼•ç”¨ Box

```rust
fn main() {
    let s: Box<str> = "hello, world".into();
    greetings(*s)
}

fn greetings(s: &str) {
    println!("{}",s)
}
```

æ˜¯çš„ï¼Œåœ¨ Rust ä¸­ï¼Œå¯ä»¥ä½¿ç”¨`*`è¿ç®—ç¬¦å¯¹`Box`è¿›è¡Œè§£å¼•ç”¨æ“ä½œã€‚è§£å¼•ç”¨`Box`ä¼šè¿”å›æŒ‡å‘å †ä¸Šåˆ†é…çš„å€¼çš„å¼•ç”¨ï¼Œä»¥ä¾¿å¯ä»¥è®¿é—®å’Œä¿®æ”¹è¯¥å€¼ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š

```rust
fn main() {
    let x = Box::new(5);

    // è§£å¼•ç”¨Boxå¹¶è®¿é—®å…¶å€¼
    println!("x = {}", *x);

    // ä¿®æ”¹è§£å¼•ç”¨åçš„å€¼
    *x = 10;
    println!("x = {}", *x);
}
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡è§£å¼•ç”¨`Box`æ¥è®¿é—®å…¶å€¼ï¼Œå¹¶æ‰“å°å‡ºæ¥ã€‚ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨è§£å¼•ç”¨æ“ä½œç¬¦`*`æ¥ä¿®æ”¹`Box`ä¸­çš„å€¼ï¼Œå¹¶å†æ¬¡æ‰“å°å‡ºæ¥ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è§£å¼•ç”¨æ“ä½œåï¼Œæˆ‘ä»¬ä»ç„¶ä¿æŒå¯¹`Box`æœ¬èº«çš„æ‰€æœ‰æƒï¼Œå› æ­¤å¯ä»¥ç»§ç»­ä½¿ç”¨å®ƒæ¥è®¿é—®å’Œä¿®æ”¹å †ä¸Šåˆ†é…çš„å€¼ã€‚

### å­—é¢é‡

`let bytestring: &[u8; 21] = b"this is a byte string";` è¿™è¡Œä»£ç çš„æ„æ€æ˜¯åœ¨ Rust ä¸­åˆ›å»ºäº†ä¸€ä¸ªåä¸º `bytestring` çš„å˜é‡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¤§å°ä¸º 21 çš„å›ºå®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„å¼•ç”¨ã€‚

å…·ä½“æ¥è¯´ï¼š

- `&[u8; 21]` è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå¯¹å¤§å°ä¸º 21 çš„ `u8` ç±»å‹æ•°ç»„çš„å¼•ç”¨ã€‚
- `b"this is a byte string"` æ˜¯ä¸€ä¸ªå­—èŠ‚å­—ç¬¦ä¸²å­—é¢é‡ï¼Œè¡¨ç¤ºä¸€ä¸ªç”± ASCII å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚

é€šè¿‡å°†å­—èŠ‚æ•°ç»„å¼•ç”¨æŒ‡å®šç»™ `bytestring` å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨å®ƒæ¥è®¿é—®å’Œæ“ä½œè¯¥å­—èŠ‚æ•°ç»„ä¸­çš„æ•°æ®ã€‚è¯·æ³¨æ„ï¼Œè¯¥å­—èŠ‚æ•°ç»„æ˜¯å›ºå®šé•¿åº¦çš„ï¼Œå› æ­¤æ— æ³•æ›´æ”¹å…¶é•¿åº¦æˆ–å‘å…¶ä¸­æ·»åŠ æˆ–åˆ é™¤å…ƒç´ ã€‚

### è½¬ç§»

```rust
fn main() {
    // æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯ `&str` ç±»å‹äº†ï¼
    let bytestring: &[u8; 21] = b"this is a byte string";


    // å­—èŠ‚æ•°ç»„æ²¡æœ‰å®ç° `Display` ç‰¹å¾ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨ `Debug` çš„æ–¹å¼å»æ‰“å°
    println!("A byte string: {:?}", bytestring);

    // å­—èŠ‚æ•°ç»„ä¹Ÿå¯ä»¥ä½¿ç”¨è½¬ä¹‰
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...ä½†æ˜¯ä¸æ”¯æŒ unicode è½¬ä¹‰
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);


    // raw string
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // å°†å­—èŠ‚æ•°ç»„è½¬æˆ `str` ç±»å‹å¯èƒ½ä¼šå¤±è´¥
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // å­—èŠ‚æ•°ç»„å¯ä»¥ä¸æ˜¯ UTF-8 æ ¼å¼
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ã‚ˆã†ã“ã" in SHIFT-JIS

    // ä½†æ˜¯å®ƒä»¬æœªå¿…èƒ½è½¬æ¢æˆ `str` ç±»å‹
    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successful: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
```

è¾“å‡ºï¼š

```rust
A byte string: [116, 104, 105, 115, 32, 105, 115, 32, 97, 32, 98, 121, 116, 101, 32, 115, 116, 114, 105, 110, 103]
Some escaped bytes: [82, 117, 115, 116, 32, 97, 115, 32, 98, 121, 116, 101, 115]
[92, 117, 123, 50, 49, 49, 68, 125, 32, 105, 115, 32, 110, 111, 116, 32, 101, 115, 99, 97, 112, 101, 100, 32, 104, 101, 114, 101]
And the same as text: '\u{211D} is not escaped here'
Conversion failed: Utf8Error { valid_up_to: 0, error_len: Some(1) }
```

### ä½¿ç”¨ utf8 çš„ slice

```rust
use utf8_slice;
fn main() {
    let s = "The ğŸš€ goes to the ğŸŒ‘!";

    let rocket = utf8_slice::slice(s, 4, 5);
    // ç»“æœæ˜¯ "ğŸš€"
}
```

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰æ–¹åº“ utf8_slice æ¥è®¿é—® UTF-8 å­—ç¬¦ä¸²çš„æŸä¸ªå­ä¸²ï¼Œä½†æ˜¯ä¸ä¹‹å‰ä¸åŒçš„æ˜¯ï¼Œè¯¥åº“ç´¢å¼•çš„æ˜¯å­—ç¬¦ï¼Œè€Œä¸æ˜¯å­—èŠ‚.

### è§£æ„å¼ èµ‹å€¼

```rust
fn main() {
    let (x, y, z);  // è¿™é‡Œè¿˜æ²¡æœ‰è¿›è¡Œç»‘å®š

    // å¡«ç©º
    (y,z,x) = (1, 2, 3);

    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);
}
```

### æ— æ³•æ‰“å°è¿‡é•¿çš„å…ƒç»„

åœ¨ Rust ä¸­ï¼Œå½“å…ƒç»„çš„é•¿åº¦è¶…è¿‡ 12 æ—¶ï¼Œæ— æ³•ç›´æ¥æ‰“å°æ•´ä¸ªå…ƒç»„ã€‚è¿™æ˜¯å› ä¸º Rust çš„æ ‡å‡†åº“ä¸­çš„ `Debug` trait å®ç°å¯¹äºè¶…è¿‡ä¸€å®šé•¿åº¦çš„å…ƒç»„æ²¡æœ‰å®šä¹‰ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ `println!` å®ç»“åˆå…ƒç»„çš„è§£æ„æ¥åˆ†åˆ«æ‰“å°å…ƒç»„çš„æ¯ä¸ªå…ƒç´ ã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);

    println!("{:?}", tuple); // è¿™è¡Œä»£ç æ— æ³•ç¼–è¯‘é€šè¿‡

    // è§£æ„å…ƒç»„å¹¶æ‰“å°æ¯ä¸ªå…ƒç´ 
    let (a, b, c, d, e, f, g, h, i, j, k, l, m, n) = tuple;
    println!("{:?}", a);
    println!("{:?}", b);
    // ...
    println!("{:?}", n);
}
```

é€šè¿‡å°†å…ƒç»„è§£æ„ä¸ºå•ç‹¬çš„å˜é‡ï¼Œå¹¶åˆ†åˆ«æ‰“å°æ¯ä¸ªå˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥é¿å…ç›´æ¥æ‰“å°è¿‡é•¿çš„å…ƒç»„è€Œå¯¼è‡´çš„ç¼–è¯‘é”™è¯¯ã€‚è¯·æ³¨æ„ï¼Œè¿™ç§æ–¹æ³•é€‚ç”¨äºä»»æ„é•¿åº¦çš„å…ƒç»„ã€‚

### å…ƒç»„å¯ä»¥ ç”¨äº ä¼ å‚ å’Œ è¿”å›å€¼

```rust
fn main() {
    let (x, y) = sum_multiply( (2, 3) );

    assert_eq!(x, 5);
    assert_eq!(y, 6);
}

fn sum_multiply(nums: (i32, i32)) -> (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
```

### åˆ‡ç‰‡

```rust
fn main() {
    let arr = [1, 2, 3];
    let s1: &[i32] = &arr[0..2];

    let s2: &str = "hello, world" as &str;
}
```

`let s2: &str = "hello, world" as &str;`è¿™æ®µä»£ç çš„æ„æ€æ˜¯å°†å­—ç¬¦ä¸²å­—é¢é‡ `"hello, world"`
è½¬æ¢ä¸ºä¸€ä¸ª `&str` ç±»å‹çš„å¼•ç”¨ï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™å˜é‡ `s2`ã€‚

åœ¨ Rust ä¸­ï¼Œå­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ `&'static str`ï¼Œ
å®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘é™æ€å†…å­˜çš„ä¸å¯å˜å¼•ç”¨ã€‚
è€Œå˜é‡ `s2` çš„ç±»å‹å£°æ˜ä¸º `&str`ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜çš„å­—ç¬¦ä¸²å¼•ç”¨ã€‚

é€šè¿‡ä½¿ç”¨ `as` å…³é”®å­—ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œç±»å‹è½¬æ¢ï¼Œå°†å­—ç¬¦ä¸²å­—é¢é‡è½¬æ¢ä¸º `&str` ç±»å‹çš„å¼•ç”¨ã€‚
è¿™ç§è½¬æ¢æ˜¯éšå¼çš„ï¼Œå› æ­¤åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`as &str` éƒ¨åˆ†å¯ä»¥çœç•¥ã€‚

æœ€ç»ˆï¼Œå˜é‡ `s2` å°†æŒæœ‰å­—ç¬¦ä¸²å­—é¢é‡ `"hello, world"` çš„ä¸å¯å˜å¼•ç”¨ï¼Œ
å¯ä»¥åœ¨ä»£ç ä¸­ä½¿ç”¨å®ƒæ¥è®¿é—®å’Œæ“ä½œè¯¥å­—ç¬¦ä¸²çš„å†…å®¹ã€‚

### ç»“æ„ä½“ æ„é€ è¯­æ³•

```rust
// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from("someone@example.com"),
        username: String::from("sunface"),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);
}

fn set_email(u: User) -> User {
    User {
        email: String::from("contact@im.dev"),
        ..u
    }
}
```

### æ‰“å°ç»“æ„ä½“

```rust

// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr,å¹¶å°† `30 * scale` çš„å€¼èµ‹ç»™ `width`
        height: 50,
    };

    dbg!(&rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr

    println!("{:?}", rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†è¾“å‡º stdout
}
```

ä¸€ä¸ªæ˜¯`println!("{:?}", rect1);`ï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯`#[derive(Debug)]`

### rust ä¸­çš„ enum ç±»å‹ï¼Œå¯ä»¥å…³è”æ•°æ®

```rust
enum PokerCard {
    Clubs(u8),
    Spades(u8),  // å…³è”äº†æ•°æ®
    Diamonds(char),
    Hearts(char),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds('A');
}
```

### enum å…³è”ç»“æ„ä½“

ç¡®å®ï¼Œè¿™ç§ å…³è”æ•°æ® æœ‰ç‚¹æ„æ€

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },  // åŒ¿åç»“æ„ä½“
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};  // å› ä¸ºæ˜¯ ç»“æ„ä½“ï¼Œå› æ­¤å¾—è¿™æ ·åˆå§‹åŒ–
    let m3 = Message::ChangeColor(255,255,0);
}
```

### option æšä¸¾

rust å®˜æ–¹æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š

```rust
enum Option<T> {
    Some(T),
    None,
}
```

ä¸€ä¸ªå˜ä½“(variant) æ˜¯ Someï¼Œä¸€ä¸ªæ˜¯ None

ä¾‹å¦‚ï¼š

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

åé¢æ¨¡å¼åŒ¹é…è¿˜ä¼š è®²åˆ°

### enum ä¸­ï¼Œåªèƒ½æ˜¯ æœ‰ç¬¦å· æ•´æ•° ç±»å‹

åœ¨ Rust ä¸­ï¼Œ`isize` æ˜¯ä¸€ç§æ•´æ•°ç±»å‹ï¼Œå®ƒçš„å¤§å°å’Œå½“å‰å¹³å°çš„æŒ‡é’ˆå¤§å°ç›¸åŒã€‚åœ¨ 64 ä½ç³»ç»Ÿä¸Šï¼Œ`isize` çš„å¤§å°ä¸º 8 å­—èŠ‚ï¼Œè€Œåœ¨ 32 ä½ç³»ç»Ÿä¸Šï¼Œ`isize` çš„å¤§å°ä¸º 4 å­—èŠ‚ã€‚

`isize` å¯ä»¥è¡¨ç¤ºæœ‰ç¬¦å·çš„æ•´æ•°å€¼ï¼ŒèŒƒå›´ä» $-2^{(n-1)}$ åˆ° $2^{(n-1)}-1$ï¼Œå…¶ä¸­ `n` æ˜¯ `isize` çš„ä½æ•°ã€‚ä¾‹å¦‚ï¼Œåœ¨ 64 ä½ç³»ç»Ÿä¸Šï¼Œ`isize` çš„ä½æ•°æ˜¯ 64ï¼Œå› æ­¤å®ƒå¯ä»¥è¡¨ç¤ºçš„èŒƒå›´æ˜¯ $-2^{63}$ åˆ° $2^{63}-1$ã€‚

`isize` ç±»å‹é€šå¸¸ç”¨äºéœ€è¦è·¨å¹³å°æ”¯æŒçš„ä»£ç ä¸­ï¼Œå› ä¸ºå®ƒçš„å¤§å°ä¼šæ ¹æ®ä¸åŒçš„å¹³å°è€Œå˜åŒ–ã€‚åœ¨ Rust ä¸­ï¼ŒRust æ ‡å‡†åº“ä¸­çš„ä¸€äº›ç±»å‹å’Œå‡½æ•°ï¼Œå¦‚ `Vec` å’Œ `slice`ï¼Œéƒ½ä½¿ç”¨äº† `isize` ç±»å‹æ¥è¡¨ç¤ºé•¿åº¦æˆ–ç´¢å¼•ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº `isize` æ˜¯æœ‰ç¬¦å·çš„æ•´æ•°ç±»å‹ï¼Œå› æ­¤åœ¨è¿›è¡Œç®—æœ¯è¿ç®—æ—¶å¯èƒ½ä¼šå‘ç”Ÿæº¢å‡ºã€‚å¦‚æœéœ€è¦è¡¨ç¤ºæ›´å¤§æˆ–æ›´å°çš„æ•´æ•°å€¼ï¼Œå¯ä»¥ä½¿ç”¨ `i128` æˆ– `i64`ï¼ˆåœ¨ 64 ä½ç³»ç»Ÿä¸Šï¼‰æˆ– `i32`ï¼ˆåœ¨ 32 ä½ç³»ç»Ÿä¸Šï¼‰ç­‰æ›´å¤§çš„æ•´æ•°ç±»å‹ã€‚

### enum ç±»å‹çš„ å¼ºåˆ¶è½¬æ¢

```rust

// ä¿®å¤é”™è¯¯
enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// Cè¯­è¨€é£æ ¼çš„æšä¸¾å®šä¹‰
enum Number2 {
    Zero = 0,
    One = 1,
    Two = 2,
}


fn main() {
    // é€šè¿‡ `as` å¯ä»¥å°†æšä¸¾å€¼å¼ºè½¬ä¸ºæ•´æ•°ç±»å‹
    assert_eq!(Number::One as i32, Number1::One as i32);
    assert_eq!(Number1::One as i32, Number2::One as i32);
}
```

### è§£æ„

```rust
// å¡«ç©ºè®© `println` è¾“å‡ºï¼ŒåŒæ—¶æ·»åŠ ä¸€äº›ä»£ç ä¸è¦è®©æœ€åä¸€è¡Œçš„ `panic` æ‰§è¡Œåˆ°
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let Some(n) = six {  // è¿™ä¹Ÿåªæ˜¯è§£æ„
        println!("{}", n);
        return;
    }

    panic!("ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼");
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
```

### ä½¿ç”¨ enum åˆ›å»º é“¾è¡¨

```rust
// å¡«ç©ºï¼Œè®©ä»£ç è¿è¡Œ
use crate::List::*;

enum List {
    // Cons: é“¾è¡¨ä¸­åŒ…å«æœ‰å€¼çš„èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ˜¯å…ƒç»„ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
    Cons(u32, Box<List>),
    // Nil: é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºè¯´æ˜é“¾è¡¨çš„ç»“æŸ
    Nil,
}

// ä¸ºæšä¸¾å®ç°ä¸€äº›æ–¹æ³•
impl List {
    // åˆ›å»ºç©ºçš„é“¾è¡¨
    fn new() -> List {
        // å› ä¸ºæ²¡æœ‰èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å› Nil èŠ‚ç‚¹
        // æšä¸¾æˆå‘˜ Nil çš„ç±»å‹æ˜¯ List
        Nil
    }

    // åœ¨è€çš„é“¾è¡¨å‰é¢æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›æ–°çš„é“¾è¡¨
    fn prepend(self, elem: u32) -> List {
        Cons(elem, Box::new(self))
    }

    // è¿”å›é“¾è¡¨çš„é•¿åº¦
    fn len(&self) -> u32 {
        match *self {
            // è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ‹¿èµ° tail çš„æ‰€æœ‰æƒï¼Œå› æ­¤éœ€è¦è·å–å®ƒçš„å¼•ç”¨
            Cons(_, ref tail) => 1 + tail.len(),
            // ç©ºé“¾è¡¨çš„é•¿åº¦ä¸º 0
            Nil => 0
        }
    }

    // è¿”å›é“¾è¡¨çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ï¼Œç”¨äºæ‰“å°è¾“å‡º
    fn stringify(&self) -> String {
        match *self {
            Cons(head, ref tail) => {
                // é€’å½’ç”Ÿæˆå­—ç¬¦ä¸²
                format!("{}, {}", head, tail.stringify())
            },
            Nil => {
                format!("Nil")
            },
        }
    }
}

fn main() {
    // åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨(ä¹Ÿæ˜¯ç©ºçš„)
    let mut list = List::new();

    // æ·»åŠ ä¸€äº›å…ƒç´ 
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // æ‰“å°åˆ—è¡¨çš„å½“å‰çŠ¶æ€
    println!("é“¾è¡¨çš„é•¿åº¦æ˜¯: {}", list.len());
    println!("{}", list.stringify());
}
```

### trait

### io æ“ä½œ

1. ä» ç»ˆç«¯ ä¸­è¯»å–

```rust
io::stdin().read_line(&mut index).expect("Failed to read line");
```

è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯ä»æ ‡å‡†è¾“å…¥ä¸­è¯»å–ä¸€è¡Œæ–‡æœ¬ï¼Œå¹¶å°†å…¶å­˜å‚¨åˆ° `index` å˜é‡æ‰€å¼•ç”¨çš„å­—ç¬¦ä¸²ä¸­ã€‚å…·ä½“è§£é‡Šå¦‚ä¸‹ï¼š

- `io::stdin()`ï¼šè¿™æ˜¯ Rust æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè·å–æ ‡å‡†è¾“å…¥çš„å¥æŸ„ã€‚
- `read_line(&mut index)`ï¼šè¿™æ˜¯ `stdin()` å‡½æ•°è¿”å›çš„å¥æŸ„ä¸Šçš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºè¯»å–ä¸€è¡Œæ–‡æœ¬ã€‚å®ƒæ¥å—ä¸€ä¸ªå¯å˜çš„å­—ç¬¦ä¸²å¼•ç”¨ `&mut index`ï¼Œè¡¨ç¤ºè¦å°†è¯»å–çš„æ–‡æœ¬å­˜å‚¨åˆ°è¯¥å­—ç¬¦ä¸²ä¸­ã€‚
- `.expect("Failed to read line")`ï¼šè¿™æ˜¯ä¸€ä¸ªé”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå¦‚æœè¯»å–è¡Œå¤±è´¥ï¼Œåˆ™ä¼šæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯ "Failed to read line"ã€‚

è¿™æ®µä»£ç é€šå¸¸ç”¨äºä»ç”¨æˆ·è¾“å…¥ä¸­è·å–æ•°æ®ï¼Œå¹¶å°†å…¶å­˜å‚¨åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²å˜é‡ä¸­ã€‚é€šè¿‡ä½¿ç”¨å¯å˜å¼•ç”¨ `&mut`ï¼Œå¯ä»¥åœ¨è¯»å–è¡Œæ—¶ä¿®æ”¹ `index` å˜é‡çš„å€¼ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™æ®µä»£ç å‡è®¾ `index` æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å¯å˜å­—ç¬¦ä¸²å˜é‡ï¼Œå¹¶ä¸”åœ¨ä½¿ç”¨ä¹‹å‰å·²ç»è¿›è¡Œäº†é€‚å½“çš„åˆå§‹åŒ–ã€‚

2. è§£æå­—ç¬¦ä¸²

```rust
let index: usize = index.trim().parse().expect("Index entered was not a number");
```

è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯å°†å­—ç¬¦ä¸²ç±»å‹çš„ `index` å˜é‡è¿›è¡Œå¤„ç†ï¼Œå°†å…¶å»é™¤é¦–å°¾ç©ºç™½å­—ç¬¦åè½¬æ¢ä¸º `usize` ç±»å‹çš„æ•´æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ° `index` å˜é‡ä¸­ã€‚

å…·ä½“è§£é‡Šå¦‚ä¸‹ï¼š

- `index.trim()`ï¼š`trim()` æ˜¯ `String` ç±»å‹çš„ä¸€ä¸ªæ–¹æ³•ï¼Œç”¨äºå»é™¤å­—ç¬¦ä¸²ä¸¤ç«¯çš„ç©ºç™½å­—ç¬¦ï¼ˆåŒ…æ‹¬ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ç­‰ï¼‰ã€‚
- `.parse()`ï¼š`parse()` æ˜¯ä¸€ä¸ªé€šç”¨çš„æ–¹æ³•ï¼Œç”¨äºå°†å­—ç¬¦ä¸²è§£æä¸ºå…¶ä»–ç±»å‹çš„å€¼ã€‚åœ¨è¿™é‡Œï¼Œå®ƒå°†å»é™¤ç©ºç™½å­—ç¬¦åçš„å­—ç¬¦ä¸²è§£æä¸º `usize` ç±»å‹çš„æ•´æ•°ã€‚
- `expect("Index entered was not a number")`ï¼š`expect()` æ˜¯ä¸€ä¸ªé”™è¯¯å¤„ç†æ–¹æ³•ï¼Œç”¨äºåœ¨è§£æå¤±è´¥æ—¶æ‰“å°é”™è¯¯ä¿¡æ¯ã€‚å¦‚æœè§£æè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼ˆä¾‹å¦‚å­—ç¬¦ä¸²ä¸æ˜¯æœ‰æ•ˆçš„æ•°å­—ï¼‰ï¼Œå°†æ‰“å°å‡ºæŒ‡å®šçš„é”™è¯¯ä¿¡æ¯ã€‚

è¿™æ®µä»£ç é€šå¸¸ç”¨äºä»ç”¨æˆ·è¾“å…¥ä¸­è·å–ä¸€ä¸ªè¡¨ç¤ºç´¢å¼•æˆ–é•¿åº¦çš„æ•°å­—ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸º `usize` ç±»å‹ä»¥ä¾›åç»­ä½¿ç”¨ã€‚å¦‚æœç”¨æˆ·è¾“å…¥çš„å­—ç¬¦ä¸²ä¸æ˜¯æœ‰æ•ˆçš„æ•°å­—ï¼Œå°†ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä½¿ç”¨è¿™æ®µä»£ç ä¹‹å‰ï¼Œ`index` å˜é‡éœ€è¦å…ˆå£°æ˜ä¸º `String` ç±»å‹ï¼Œå¹¶ä¸”åœ¨ä½¿ç”¨ä¹‹å‰å·²ç»è¿›è¡Œäº†é€‚å½“çš„åˆå§‹åŒ–ã€‚

### åˆå§‹åŒ– é•¿åº¦ä¸€å®š çš„ ç›¸åŒå…ƒç´  çš„ æ•°ç»„ ï¼ˆå¤åˆç±»å‹ï¼‰

```rust
let array = [String::from("rust is good!"); 8];

println!("{:#?}", array);
```

BOOM! å› ä¸ºè¿™ç§æ˜¯æµ…æ‹·è´ï¼Œæ‰€æœ‰æƒ é—®é¢˜

```rust
let array: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));

println!("{:#?}", array);
```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`|_i|` æ˜¯ä¸€ä¸ªé—­åŒ…ï¼ˆClosureï¼‰çš„å‚æ•°åˆ—è¡¨ï¼Œç”¨äºæ¥æ”¶é—­åŒ…æ‰€éœ€çš„å‚æ•°ã€‚åœ¨è¿™é‡Œï¼Œ`_i` æ˜¯ä¸€ä¸ªåŒ¿åçš„å ä½ç¬¦ï¼Œè¡¨ç¤ºé—­åŒ…æ¥æ”¶ä¸€ä¸ªæœªä½¿ç”¨çš„å‚æ•°ã€‚

é—­åŒ…æ˜¯ä¸€ç§å¯ä»¥å­˜å‚¨å˜é‡å¹¶åœ¨ç¨åæ‰§è¡Œçš„åŒ¿åå‡½æ•°ã€‚å®ƒå¯ä»¥åœ¨éœ€è¦æ—¶æ•è·å¤–éƒ¨å˜é‡ï¼Œå¹¶åœ¨é—­åŒ…ä½“ä¸­ä½¿ç”¨ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé—­åŒ…æ²¡æœ‰ä½¿ç”¨å‚æ•° `_i`ï¼Œåªæ˜¯ç®€å•åœ°è¿”å›äº†ä¸€ä¸ªå›ºå®šçš„å­—ç¬¦ä¸² "rust is good!"ã€‚

é—­åŒ…çš„å‚æ•°åˆ—è¡¨å¯ä»¥æ ¹æ®å®é™…éœ€è¦è¿›è¡Œå®šä¹‰ï¼Œæ ¹æ®ä»£ç çš„è¦æ±‚æ¥ç¡®å®šé—­åŒ…æ˜¯å¦éœ€è¦æ¥æ”¶å‚æ•°ä»¥åŠå‚æ•°çš„ç±»å‹ã€‚

### rust çš„ char æ˜¯ unicodeï¼› å¯å¿½ç•¥ç±»å‹

```rust
fn main() {
    // å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ•°ç»„çš„éƒ¨åˆ†ç±»å‹ï¼Œä¹Ÿå¯ä»¥å¿½ç•¥å…¨éƒ¨ç±»å‹ï¼Œè®©ç¼–è¯‘å™¨å¸®åŠ©æˆ‘ä»¬æ¨å¯¼
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];

    // æ•°ç»„åˆ†é…åœ¨æ ˆä¸Šï¼Œ `std::mem::size_of_val` å‡½æ•°ä¼šè¿”å›æ•´ä¸ªæ•°ç»„å ç”¨çš„å†…å­˜ç©ºé—´
    // æ•°ç»„ä¸­çš„æ¯ä¸ª char å…ƒç´ å ç”¨ 4 å­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œå› ä¸ºåœ¨ Rust ä¸­ï¼Œ char æ˜¯ Unicode å­—ç¬¦
    assert!(std::mem::size_of_val(&arr) == 12);
}
```

### åˆå§‹åŒ– ç›¸åŒå€¼

```rust
fn main() {
    let list: [i32; 100] = [1; 100];

    assert!(list[0] == 1);
    assert!(list.len() == 100);
}
```

### array çš„ get æ–¹æ³•

```rust

// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯
fn main() {
    let names = [String::from("Sunfei"), "Sunface".to_string()];

    // `get` è¿”å› `Option<T>` ç±»å‹ï¼Œå› æ­¤å®ƒçš„ä½¿ç”¨éå¸¸å®‰å…¨
    let name0 = names.get(0).unwrap();

    // ä½†æ˜¯ä¸‹æ ‡ç´¢å¼•å°±å­˜åœ¨è¶Šç•Œçš„é£é™©äº†
    let _name1 = &names[2];
}
```
