# README - 生命周期

## 闭包函数（匿名函数）

在 Rust 中，闭包和普通函数的一个关键区别是闭包可以捕获其所在作用域中的变量。
Rust 通过三个 trait 来表达闭包如何捕获这些变量：`Fn`、`FnMut`和`FnOnce`。
这些 trait 分别定义了闭包对环境的捕获方式，以及它们如何被调用。下面是对这三个 trait 的解释和示例：

### `Fn`

当一个闭包实现了`Fn`trait，它可以通过不可变引用（`&T`）捕获环境中的变量。这意味着闭包内部可以访问和读取这些变量，但不能修改它们。

```rust
let x = 4;
let equal_to_x = |z| z == x; // 使用不可变引用捕获x
assert!(equal_to_x(4));
```

在这个示例中，闭包`equal_to_x`通过不可变引用捕获了变量`x`。因为它不需要修改`x`，所以它实现了`Fn`trait。

### `FnMut`

当一个闭包实现了`FnMut`trait，它可以通过可变引用（`&mut T`）捕获环境中的变量。这允许闭包不仅访问和读取这些变量，还可以修改它们。

```rust
let mut x = 4;
let mut increment_x = || x += 2; // 使用可变引用捕获x
increment_x();
assert_eq!(x, 6);
```

这个示例中的闭包`increment_x`需要修改它捕获的变量`x`，因此它实现了`FnMut`trait。

### `FnOnce`

当一个闭包实现了`FnOnce`trait，这意味着它会取得其捕获变量的所有权。
这样的闭包可以被调用一次，因为它可能会消耗（移动）捕获的变量，使得这些变量在闭包被调用后不再有效。

```rust
let x = String::from("hello");
let consume_x = || drop(x); // 消耗x，取得x的所有权
consume_x();
// 在这里再调用consume_x将会导致编译错误，因为x已经被移动
```

在这个示例中，闭包`consume_x`通过取得所有权来捕获变量`x`，因此它实现了`FnOnce`trait。由于`x`在闭包被调用后不再有效，这个闭包只能被调用一次。

### 总结

- `Fn`：允许通过不可变引用捕获环境变量，可以多次调用。
- `FnMut`：允许通过可变引用捕获环境变量，可以多次调用，但每次调用可能会修改环境变量。
- `FnOnce`：通过取得环境变量的所有权来捕获它们，因为它可能会消耗这些变量，所以只能被调用一次。

选择使用哪种 trait 取决于闭包如何使用它捕获的环境变量。Rust 编译器会根据闭包体内的操作自动推断使用哪个 trait。

## BOX::leak

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option<&mut Config> = None;

/* 让代码工作，但不要修改函数的签名 */
fn init() -> Option<&'static mut Config> {
    let c = Box::new(Config { a: "A".to_string(), b: "B".to_string() });

    Some(Box::leak(c))
}

fn main() {
    unsafe {
        config = init();

        println!("{:?}", config)
    }
}
```

在你提供的代码中，`Box::leak` 被用来创建一个 `'static` 生命周期的引用。
这是因为 `Box::leak` 函数将一个 `Box<T>` 的所有权“泄漏”了，这意味着数据不会在其正常的作用域结束时被丢弃。
具体来说，`Box::leak` 接受一个 `Box<T>` 并返回一个指向 `Box` 内部数据的可变引用（`&'static mut T`），
这个引用的生命周期是 `'static`，即它可以在程序的任何地方被访问，而不会被自动回收。

这种技术使得数据实际上拥有了一个静态的生命周期，因为它不会被自动销毁。
这就是为什么你可以从 `init` 函数中返回一个 `Option<&'static mut Config>` 类型的值，即便这个值是在函数内部创建的。
通过调用 `Box::leak`，你有效地将 `Box` 内的数据的生命周期提升为 `'static`，从而能够安全地返回一个指向这些数据的静态引用。

然而，使用 `Box::leak` 也意味着这块内存不会被自动回收，这可能导致内存泄露，特别是如果这个操作被频繁执行时。
在实践中，`Box::leak` 应该被谨慎使用，只在确实需要将数据的生命周期提升为 `'static` 时使用。
它是一个有用但潜在的危险的工具，因为它绕过了 Rust 的自动内存管理。

参考自《Effective Rust》文档，`Box::leak` 函数将一个拥有的 `Box<T>` 转换为 `T` 的可变引用，
这个操作没有所有者，所以这个值永远不会被丢弃，满足 `'static` 生命周期的要求。
这种技术的一个缺点是，持有这个项目的内存永远不会被安全 Rust 回收，可能导致永久性的内存泄露。
回收这些内存需要使用不安全代码，因此这是一种应该保留用于特殊情况的技术【12†source】。

## 双重引用

```rust
fn f<'a: 'b, 'b>(x: &'a i32, mut y: &'b i32) {
    y = x;
    let r: &'b &'a i32 = &&0;
}
```

这段代码中的 `fn f<'a: 'b, 'b>(x: &'a i32, mut y: &'b i32)` 使用了生命周期参数 `'a` 和 `'b`，并且有一个约束：`'a: 'b`。
这意味着所有 `'a` 生命周期的实例至少与 `'b` 生命周期一样长。
然后，函数接受两个参数：`x`，它的生命周期至少和 `'a` 一样长，和 `y`，它的生命周期至少和 `'b` 一样长。

在函数体中，`y` 被重新赋值为 `x` 的引用。
由于 `'a: 'b` 的约束，这是允许的，因为 `x` 的生命周期至少与 `y` 一样长，所以 `x` 的引用可以安全地赋值给 `y`。

对于 `let r: &'b &'a i32 = &&0;` 这行代码，它试图创建一个双重引用 `&&0`，其中外层引用的生命周期是 `'b`，内层引用的生命周期是 `'a`。
这里使用的是数字字面量 `0`，它具有 `'static` 生命周期，即它的生命周期是整个程序的持续时间。
Rust 允许将 `'static` 生命周期的引用缩短为更短的生命周期，因此可以将 `&&0` 的内层引用视为具有 `'a` 生命周期（因为 `'static: 'a` 总是成立），
外层引用视为具有 `'b` 生命周期（因为 `'a: 'b`，从而 `'static: 'b` 也成立）。

然而，这个特定的赋值操作可能会引起混淆，因为它试图在类型系统中表达关于生命周期的复杂关系，尤其是在涉及到生命周期参数和静态生命周期之间的自动协变转换时。
关键点在于理解 `'a: 'b` 表示 `'a` 至少和 `'b` 一样长，以及 Rust 允许 `'static` 生命周期的引用被自动缩短以匹配更具体的生命周期约束。
